<?php // $Id$

define (BRLCAD_NODETYPE, 'model');

/**
 * Implementation of hook_menu
 */
function brlcad_menu($may_cache) {
  $links = array();
  if($may_cache) {
      
  } else {
    $links[] = array(
      'path' => 'admin/content/brlcad',
      'title' => t('BRL-CAD'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('brlcad_general_settings'),
    );
  }
  return $links;
}

/**
 * General settings form for BRL-CAD.
 */
function brlcad_general_settings() {
  $queues = nodequeue_load_queues(array_keys(nodequeue_get_qids('model')));
  foreach($queues as $qid => $queue) {
    $queues[$qid] = $queue->title;
  }
  $form = array();
  $form['system'] = array(
    '#type' => 'fieldset',
    '#title' => t('BRL-CAD system'),
    '#tree' => false,
  );
  $form['system']['brlcad_version'] = array(
    '#type' => 'select',
    '#title' => t('Version'),
    '#options' => _brlcad_supported_versions(),
    '#default_value' => variable_get('brlcad_version', '7.12'),
    '#required' => true,
  );
  $form['system']['brlcad_bin_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Path to binaries'),
    '#default_value' => variable_get('brlcad_bin_path', '/usr/brlcad/bin'),
    '#required' => true,
  );
  $form['queues'] = array(
    '#type' => 'fieldset',
    '#title' => t('Processing queues'),
    '#tree' => false,
    '#description' => t('Use distinct queues for each task. Nodes will be automatically removed from queues after processing.'),
  );
  $form['queues']['brlcad_queue_metadata'] = array(
    '#title' => t('Retrieve metadata'),  
    '#type' => 'select',
    '#options' => $queues,
    '#default_value' => variable_get('brlcad_queue_metadata', 0),
  );
  $form['queues']['brlcad_queue_raytrace'] = array(
    '#title' => t('Raytrace'),  
    '#type' => 'select',
    '#options' => $queues,
    '#default_value' => variable_get('brlcad_queue_raytrace', 0),
  );
  return system_settings_form($form);
}

/**
 * Implementation of hook_nodeapi
 */
function brlcad_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if($node->type != BRLCAD_NODETYPE) {
    return;
  }
  switch($op) {
    default:
      break;
    case 'submit':
      // @todo remove this when the queing processing is done
      brlcad_mged_metadata($node);
      break;
    case 'insert':
      _brlcad_queue($node, variable_get('brlcad_queue_metadata', 0));
      _brlcad_queue($node, variable_get('brlcad_queue_raytrace', 0));
      break;
  }
}

function brlcad_form_alter($form_id, &$form) {
  if($form_id != BRLCAD_NODETYPE . '_node_form') {
    return;
  }
  if(arg(0) == 'node') {
    unset($form['group_metadata']);
  }
  return;
  $hidden = array(
    0 => array('field_image_file', 'body_filter', 'log', 'preview'),
    1 => array('comment_settings', 'menu', 'path', 'captcha', 'field_license', 'field_model_file'), 
  );
  $step = isset($form['#post']['step']) ? (int)$form['#post']['step'] : 0;
  foreach($hidden[$step] as $name) {
    unset($form[$name]);
  }
  $fomr['step'] = array(
    '#type' => 'hidden',
    '#value' => $step + 1,
  );
  $form['#multistep'] = true;
  $form['submit']['#type'] = 'button';
  $form['submit']['#value'] = 'Next';
}

function brlcad_raytrace(&$node) {
  brlcad_mged_run_script('raytrace.txt', $node->field_model_file[0]['filepath']);
}

function brlcad_mged_metadata(&$node) {
  $output = explode("\n", brlcad_mged_run_script('metadata.txt', $node->field_model_file[0]['filepath']));
  
  $node->field_dbversion[0]['value'] = $output[0];
  $node->field_title[0]['value'] = $output[1];
  $node->field_units[0]['value'] = $output[2];
  $node->field_summary[0]['value'] = $output[3];
}

function _brlcad_queue(&$node, $qid) {
  if(!$qid) {
    return;
  }
  $queue = nodequeue_load($qid);
  if(!$qid) {
    return;
  }
  $subqueue = reset(nodequeue_load_subqueues_by_queue($queue->qid));
  if(!$subqueue) {
    return;
  }
  nodequeue_subqueue_add($queue, $subqueue, $node->nid);
}

function brlcad_mged_run_command($command, $model = null, $cwd = null, $env = null) {
  return _brlcad_mged_run_real_command(escapeshellarg($command), $model, $cwd, $env);
}

function brlcad_mged_run_script($script, $model = null, $cwd = null, $env = null) {
  $script = realpath(drupal_get_path('module', 'brlcad') . '/scripts/' . variable_get('brlcad_version', '') . '/' . $script);
  if(empty($script)) {
    return null;
  }
  return _brlcad_mged_run_real_command('<' . escapeshellarg($script), $model, $cwd, $env);
}


function _brlcad_mged_run_real_command($command, $model = null, $cwd = null, $env = null) {
  if(is_array($vars)) {
    $setvars = '';
    foreach($vars as $key => $value) {
      $key = escapeshellarg($key);
      $value = escapeshellarg($value); 
    }
  }
  $cmd = escapeshellcmd(variable_get('brlcad_bin_path', '/usr/brlcad/bin') . '/mged');
  $cmd .= ' -cr ';
  $model = realpath($model);
  if($model) {
    $model = escapeshellarg($model);
    $cmd .= $model ;
  }
  $cmd .= $command .  ' 2>&1';
  $descriptorspec = array(
    1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
  );
  $process = proc_open($cmd, $descriptorspec, $pipes, $cwd, $env);
  if (!is_resource($process)) {
    return null;
  }
  $output = stream_get_contents($pipes[1]);
  fclose($pipes[1]);

  // It is important that you close any pipes before calling proc_close in order to avoid a deadlock
  $return_value = proc_close($process);
  if($return_value) {
    return null;
  }
  // trim leading warning Opened in READ ONLY mode
  $output = substr($output, 25);
  return $output;
}

function _brlcad_supported_versions() {
  static $supported;
  if(!isset($supported)) {
    $supported = glob(drupal_get_path('module', 'brlcad') . '/scripts/*');
    foreach($supported as $key => $value) {
      if(is_dir($value)) {
        $supported[$key] = basename($value);
      } else {
        unset($supported[$key]);
      }
    }
    if(!empty($supported)) {
      $supported = array_combine($supported, $supported);
    }
  }
  return $supported;
}