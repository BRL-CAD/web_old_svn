<?php // $Id$

define (BRLCAD_NODETYPE, 'model');

/**
 * Implementation of hook_perm
 */
function brlcad_perm() {
  return array('edit metadata', 'manage files');
}


/**
 * Implementation of hook_menu
 */
function brlcad_menu($may_cache) {
  $links = array();
  if($may_cache) {
    $links[] = array(
      'path' => 'admin/content/brlcad',
      'title' => t('BRL-CAD'),
      'callback' => 'drupal_get_form',
      'callback arguments' => array('brlcad_general_settings'),
    );
    $links[] = array(
      'path' => 'admin/content/brlcad/process',
      'callback' => 'brlcad_process_nodes',
      'type' => MENU_CALLBACK,
      'access' => true,
    );
  }
  return $links;
}

/**
 * Implementation of hook_cron
 */
function brlcad_cron() {
  // force update of visible fields list
  _brlcad_visible_formats(false);
  brlcad_process_nodes();
}

/**
 * General settings form for BRL-CAD.
 */
function brlcad_general_settings() {
  $flags = flag_get_flags('node', BRLCAD_NODETYPE);
  foreach($flags as $flag => $data) {
    $flags[$flag] = $data->title;
  }
  $form = array();
  $form['process'] = array(
    '#value' => t('Start processing models that require BRLCAD processing !now.', array('!now' => l(t('now'), 'admin/content/brlcad/process'))),
  );
  $form['system'] = array(
    '#type' => 'fieldset',
    '#title' => t('BRL-CAD system'),
    '#tree' => false,
  );
  $form['system']['brlcad_version'] = array(
    '#type' => 'select',
    '#title' => t('Version'),
    '#options' => _brlcad_supported_versions(),
    '#default_value' => variable_get('brlcad_version', 'generic'),
    '#required' => true,
  );
  $form['system']['brlcad_bin_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Path to binaries'),
    '#default_value' => variable_get('brlcad_bin_path', '/usr/brlcad/bin'),
    '#required' => true,
  );
  $form['system']['brlcad_processing_flag'] = array(
    '#title' => t('BRL-CAD processing flag'),  
    '#type' => 'select',
    '#options' => $flags,
    '#default_value' => variable_get('brlcad_processing_flag', ''),
    '#description' => t('Select the flag which marks the nodes that require BRL-CAD specific processing.'),
  );
  $form['system']['brlcad_processing_limit'] = array(
    '#title' => t('BRL-CAD processing time limit'),  
    '#type' => 'textfield',
    '#default_value' => variable_get('brlcad_processing_limit', 600),
    '#description' => t('Enter the number of seconds after which no other processing will be started. Processing extending after this value will be allowed to finish.'),
  );
  $form['raytrace'] = array(
    '#type' => 'fieldset',
    '#title' => t('Raytracing'),
    '#tree' => false,
  );
  $form['raytrace']['brlcad_raytrace_ae'] = array(
    '#type' => 'textarea',
    '#title' => t('Views'),
    '#description' => t('Enter raytracing azimuth elevation (and optionally twist) tuples for raytracing, one per line. An image will be generated for each tuple.'),
    '#default_value' => variable_get('brlcad_raytrace_ae', ''),
  );
  $form['raytrace']['brlcad_raytrace_size'] = array(
    '#type' => 'textfield',
    '#title' => t('Size'),
    '#description' => t('Enter number of pixels of the image.'),
    '#default_value' => variable_get('brlcad_raytrace_size', 512),
  );
  $form['raytrace']['brlcad_raytrace_skip_existing'] = array(
    '#type' => 'checkbox',
    '#title' => t('Skip existing images when raytracing'),
    '#description' => t('Check this field to optimize raytracing performance, skipping views that have already been raytraced.'),
    '#default_value' => variable_get('brlcad_raytrace_skip_existing', true),
  );
  return system_settings_form($form);
}

/**
 * Implementation of hook_nodeapi
 */
function brlcad_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if($node->type != BRLCAD_NODETYPE) {
    return;
  }
  switch($op) {
    default:
      break;
    case 'submit':
      if(empty($node->nid)) {
        // this this is a new node, it will require processing
        $node->brlcad_processing = true;
      } else {
        // if this is an updated node, load the old version (from static cache)
        $node_current = node_load($node->nid);
        
        $delete_metadata = false;
        $delete_images = false;
        $delete_models = false;

        // if the model file changed, it will require processing
        if(empty($node->field_original_file[0]['filepath']) || $node->field_original_file[0]['filepath'] != $node_current->field_original_file[0]['filepath']) {
          $delete_metadata = true;
          $delete_models = true;
          $delete_images = true;
          $node->field_render_objects = null;
        }

        // if the rendering objects list changed, it will require processing
        if($node->field_render_objects != $node_current->field_render_objects) {
          $delete_images = true;
        }
        
        if($delete_images || $delete_metadata || $delete_models) {
          $node->brlcad_processing = true;
          // if we'll do brlcad processing, then clean up the node
          _brlcad_node_clear_data($node, $delete_metadata, $delete_images, $delete_models);
        }
      }
      break;
    case 'insert':
      // flag the node if it the node requires processing
      if(!empty($node->brlcad_processing)) {
        brlcad_processing_flag($node, true);
      }
      break;
    case 'update':
      // flag the node if it the node requires processing
      if(!empty($node->brlcad_processing)) {
        brlcad_processing_flag($node, true);
      }
      break;
  }
}

/**
 * Implementation of hook_alter
 */
function brlcad_form_alter($form_id, &$form) {
  if($form_id != BRLCAD_NODETYPE . '_node_form' || arg(0) != 'node') {
    return;
  }
  $node = $form['#node'];

  $form['group_files']['field_original_file']['#title'] = t('Model file');

  // hide additional file fields if the user can't manage files
  if(!user_access('manage files')) {
    foreach(_brlcad_visible_formats() as $field => $format) {
      unset($form['group_files'][$field]);
    }
  } else {
    foreach(_brlcad_visible_formats() as $field => $format) {
      // show collapsed file fieldsets
      $form['group_files'][$field]['#collapsible'] = true;
      $form['group_files'][$field]['#collapsed'] = true;
      // hide file model, if it's the same as the original file
      if(!empty($node->{$field}[0]['fid']) && !empty($node->field_original_file[0]['fid']) &&
        $node->{$field}[0]['fid'] == $node->field_original_file[0]['fid']) {
        unset($form['group_files'][$field]);
      }
    }
  }
  
  if(empty($node->nid)) {
    // this is a new node, hide all metadata
    unset($form['group_metadata']);
  } else {
    // this is an existing node

    // hide uneditable fields
    unset($form['group_metadata']['field_units']);
    unset($form['group_metadata']['field_dbversion']);
    unset($form['group_metadata']['field_summary']);
    unset($form['group_metadata']['field_objects']);

    // hide render objects field if it's not useful
    if(empty($node->field_objects[0]['value'])) {
      unset($form['group_metadata']['field_render_objects']);
    }

    // hide metadata if the user can't edit metadata
    if(!user_access('edit metadata')) {
      if(empty($node->field_render_objects)) {
        unset($form['group_metadata']);
      } else {
        unset($form['group_metadata']['field_title']);
      }
    }
  }
}

/**
 * Flags (or unflags) a model node for BRLCAD processing.
 * @param $node node to flag
 * @param $enable_flag true if the flag should be flaged, false otherwise
 * @return boolean current flaging state
 */
function brlcad_processing_flag(&$node, $enable_flag) {
  $flag = flag_get_flag(variable_get('brlcad_processing_flag', ''));
  if (!$flag || $flag->is_flagged($node->nid) == $enable_flag) {
    // Flag does not exist.
    return false;
  }
  if($enable_flag) {
    drupal_set_message(t('Your model was queued for further processing with BRL-CAD tools (metadata extraction, raytracing, conversions, etc). Upon completion, it will be updated with additional data.'));
    return $flag->flag('flag', $node->nid, _brlcad_fakeuser());
  } else {
    return $flag->flag('unflag', $node->nid, _brlcad_fakeuser());
  }
}

/**
 * Process nodes marked for BRLCAD processing.
 */
function brlcad_process_nodes($time_limit = -1) {
  $processingflag = variable_get('brlcad_processing_flag', '');
  $flags = flag_get_user_flags('node', null, 0);
  if(empty($flags[$processingflag])) {
    return;
  }
  if($time_limit < 0) {
    $time_limit = variable_get('brlcad_processing_limit', 600);
  }
  @set_time_limit(0);
  $start_time = time();
  foreach($flags[$processingflag] as $nid => $flag) {
    $node = node_load($nid);
    brlcad_process_node($node);
    node_save($node);
    // stop processing if too much time passed
    if($time_limit && $start_time + $time_limit < time()) {
      break;
    }
  }
}

/**
 * Does BRLCAD processing on a node.
 * @param object $node node to process
 */
function brlcad_process_node(&$node) {
  brlcad_processing_flag($node, false);
  brlcad_node_create_brlcad_model($node);
  brlcad_node_import_data($node);
  brlcad_node_create_other_models($node);
  $node->log = t('BRLCAD processing completed.');
}

/**
 * Run BRLCAD scripts and imports the metadata and images for a node.
 * @param $node
 * @return true if successfull
 */
function brlcad_node_import_data(&$node) {
  brlcad_load_api();

  // raytrace and get metadata
  $model = _brlcad_node_get_model($node);
  $objects = null;
  if(!empty($node->field_render_objects)) {
    $objects = content_transpose_array_rows_cols($node->field_render_objects);
    $objects = $objects['value'];
  }

  // prepare views
  $views = _brlcad_raytrace_views();
  if(is_array($node->field_image_file)) {
    $raytrace_skip_existing = variable_get('brlcad_raytrace_skip_existing', true);
    foreach($node->field_image_file as $key => $file) {
      // if this is an automatic view
      if(preg_match('|^View (.+) \(auto\)$|', $file['title'], $matches)) {
        if(!$raytrace_skip_existing) {
          // if we don't skip existing, then delete the file
          $node->field_image_file[$key]['flags']['delete'] = true;
        } else if (false===($viewkey = array_search($matches[1], $views))) {
          // if this view is not defined, then delete the file
          $node->field_image_file[$key]['flags']['delete'] = true;
        } else {
          // if we skip existing and this view is defined, else skip view
          unset($views[$viewkey]);          
        }
      }
    }
  }

  $fields = brlcad_metadata_and_rt($views, variable_get('brlcad_raytrace_size', 512), $model['filepath'], $objects);
  if(empty($fields)) {
    return;
  }

  // import metadata values
  if(empty($node->field_title[0]['value'])) {
    $node->field_title[0]['value'] = trim($fields['TITLE']);
  }
  $node->field_dbversion[0]['value'] = trim($fields['VERSION']);
  $node->field_units[0]['value'] = trim($fields['UNITS']);
  $node->field_summary[0]['value'] = trim($fields['SUMMARY']);
  $node->field_objects[0]['value'] = trim($fields['OBJECTS']);
  $node->field_render_objects = content_transpose_array_rows_cols(array('value' => $fields['RENDER']));
  unset($fields['OBJECTS']);
  // import images
  foreach($fields['IMAGES'] as $view => $pngfile) {
    $node->field_image_file[] = array(
      'title' => 'View ' . $view . ' (auto)',
      'filename' => str_replace('.', '_', $model['filename']) . '_' . str_replace(' ', '_', $view) . '.png',
      'filepath' => $pngfile,
      'filemime' => file_get_mimetype($pngfile),
      'fid' => 'upload',
      'filesize' => filesize($pngfile),
    );
  }
  return true;
}

/**
 * Converts a generic model to a BRLCAD model.
 * @param $node object containin model node data
 */
function brlcad_node_create_brlcad_model(&$node) {
  brlcad_load_api();

  // no original file ? (shouln't happen) or file already exists
  if(empty($node->field_original_file[0]['filepath']) || !empty($node->field_brlcad_file[0]['filepath'])) {
    return;
  }

  // create the brlcad file
  $file = brlcad_convert_file($node->field_original_file[0], 'brlcad');
  $node->field_brlcad_file[0] = $file;
}

/**
 * Converts a the BRLCAD model to other models.
 * @param $node object containin model node data
 */
function brlcad_node_create_other_models(&$node) {
  brlcad_load_api();

  // copy original file to the fields with the same format
  if(!empty($node->field_original_file[0]['filepath'])) {
    $original_format = brlcad_known_formats(pathinfo($node->field_original_file[0]['filename'], PATHINFO_EXTENSION), true);
    foreach(_brlcad_visible_formats() as $field => $format) {
      if($original_format == $format && empty($node->{$field}[0]['filepath'])) {
        $node->{$field}[0] = $node->field_original_file[0];
      }
    }
  }

  // no brlcad file ? (shouln't happen)
  if(empty($node->field_brlcad_file[0]['filepath'])) {
    return;
  }
  preg_match_all('|^([^;]*);|m', $node->field_objects[0]['value'], $objects);
  $objects = $objects[1];
  // if no objects then quit
  if(empty($objects)) {
    return;
  }
  // create other format
  foreach(_brlcad_visible_formats() as $field => $format) {
    if($format != 'brlcad' && empty($node->{$field}[0]['filepath'])) {
      // convert to that format
      $file = brlcad_convert_file($node->field_brlcad_file[0], $format, $objects);
      $node->{$field}[0] = $file;
    }
  }
}

/**
 * Helpder function to load the BRLCAD API.
 */
function brlcad_load_api() {
  require_once(drupal_get_path('module', 'brlcad') . '/brlcad.inc');
}

/**
 * Centralized function to return the supported formats.
 * @return array list of supported formats
 */
function _brlcad_visible_formats($use_cache = true) {
  $formats = variable_get('brlcad_formats', 0);
  if(empty($formats) || !$use_cache) {
    brlcad_load_api();
    // get fields from the model node type
    $fields = content_types(BRLCAD_NODETYPE);
    // prepare the formats array
    $formats = array('field_brlcad_file' => 'brlcad');

    // search fields that match these criterias
    // - it's not the original upload field
    // - it's a file field
    // - fits field_format_file the naming convention
    // - can be converted from BRLCAD format
    foreach($fields['fields'] as $name => $field) {
      if($name != 'field_original_file' && $field['type'] == 'file' &&
      preg_match('|^field_(.+)_file$|', $name, $matches) && function_exists('brlcad_convert_brlcad2' . $matches[1])) {
        $formats[$name] = $matches[1];
      }
    }
    variable_set('brlcad_formats', $formats);
  }
  return $formats;
}

/**
 * Helper function to retrieve information about the BRLCAD model file of a model node.
 * @param $node node to search for model
 * @return array value of the CCK model_file field (including fid, filepath, filename, etc)
 */
function _brlcad_node_get_model(&$node) {
  if(!is_array($node->field_brlcad_file)) {
    return false;
  }
  foreach($node->field_brlcad_file as $value) {
    if(empty($value['delete']) && !empty($value['filepath']) && file_exists($value['filepath'])) {
      return $value;
    }
  }
  return false;
}

/**
 * Helper function to clear metadata and raytraced images.
 * @param $node node object to clear
 * @param $delete_metadata boolean (true means delete metadata, except for title)
 * @param $delete_images boolean (true means delete images)
 * @param $delete_models boolean (true means delete model files)
 */
function _brlcad_node_clear_data(&$node, $delete_metadata, $delete_images, $delete_models) {
  // delete old data
  if($delete_metadata) {
    $node->field_title[0]['value'] = null;
    $node->field_dbversion[0]['value'] = null;
    $node->field_units[0]['value'] = null;
    $node->field_summary[0]['value'] = null;
    $node->field_objects[0]['value'] = null;
  }

  // delete old images
  if($delete_images && is_array($node->field_image_file)) {
    foreach($node->field_image_file as $key => $value) {
      if(preg_match('|^View (.+) \(auto\)$|', $node->field_image_file[$key]['title'])) {
        $node->field_image_file[$key]['flags']['delete'] = true;
      }
    }
  }

  // delete the old models file
  if($delete_models) {
    foreach(_brlcad_visible_formats() as $field => $format) {
      if(!empty($node->{$field}[0]['filepath'])) {
        $node->{$field}[0]['delete'] = true;
      }
    }
  }
}

/**
 * Retrieves the supported BRLCAD versions based on files in the scripts directory.
 * @return array supported BRLCAD versions
 */
function _brlcad_supported_versions() {
  static $supported;
  if(!isset($supported)) {
    $supported = glob(drupal_get_path('module', 'brlcad') . '/scripts/*.txt');
    foreach($supported as $key => $value) {
      if(is_file($value)) {
        $supported[$key] = str_replace('.txt', '', basename($value));
      } else {
        unset($supported[$key]);
      }
    }
    if(!empty($supported)) {
      $supported = array_combine($supported, $supported);
    }
  }
  return $supported;
}

/**
 * Helper function to create fake admin user object.
 *
 * @return object fake admin user object
 */
function _brlcad_fakeuser() {
  static $user;
  if(!isset($user)) {
    $user = user_load(array('uid' => 1));
  }
  return $user;
}

/**
 * Helper function to be used in CCK fields
 *
 * @return array
 */
function _brlcad_current_node_objects_list() {
  $objects = array();
  if(arg(0) == 'node' && is_numeric(arg(1)) && arg(2) == 'edit' && ($node = node_load(arg(1)))) {
    $text = explode("\n", $node->field_objects[0]['value']);
    foreach($text as $line) {
      list($name, $type) = explode(';', $line);
      // trim the type suffix for combinations and regions (/ or /R)
      if($suffix = strrpos($name, '/')) {
        $name = substr($name, 0, $suffix);
      }
      $objects[$name] = $name . ';' . $type;
    }
  }
  return $objects;
}

/**
 * Parses and returns the list of views.
 * @return array of "azimuth elevation twist" strings
 */
function _brlcad_raytrace_views() {
  static $views;
  if(!isset($views)) {
    $views = explode("\n", variable_get('brlcad_raytrace_ae', '0 0'));
    foreach($views as $key => $view) {
      $views[$key] = trim($view);
    }
  }
  return $views;
}